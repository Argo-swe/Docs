\subsection{Verifica}\label{verifica}

\subsubsection{Scopo}

\par Il processo di verifica ha lo scopo di determinare se i risultati di un'attività soddisfano i requisiti, le condizioni e i vincoli stabiliti nel \PianoDiQualifica. Questo processo può includere:
\begin{itemize}
  \item \textbf{Analisi};
  \item \textbf{Revisione};
  \item \textbf{Testing}.
\end{itemize}

\vspace{0.5\baselineskip}
\par I task coinvolti nel processo di verifica sono finalizzati a garantire l'adeguatezza, completezza e coerenza del prodotto. Questi task comprendono:
\begin{itemize}
  \item Verifica dei processi;
  \item Verifica dei requisiti software;
  \item Verifica del design;
  \item Verifica del codice sorgente;
  \item Verifica dell'integrazione;
  \item Verifica della documentazione.
\end{itemize}

\subsubsection{Descrizione}

\par Per assicurare la conformità dei risultati prodotti, a ogni azione di modifica è associato un passo di verifica. L’avanzamento di versione avviene soltanto a valle di verifica e conseguente approvazione. Il processo di revisione viene svolto dai membri impiegati nel ruolo di verificatore. Come indicato nella \sezione{sec:pull_request}, il gruppo ha definito delle Branch Protection Rules, al fine di garantire un'integrazione controllata delle modifiche all'interno del \glossario{repository}. In linea con le specifiche di GitHub, la verifica non può essere effettuata dallo stesso componente a cui è stato assegnato il task.

\subsubsection{Analisi statica}
\par L’analisi statica è un approccio alla verifica che prevede una disamina del software e dei documenti alla ricerca di difetti, senza richiedere l’esecuzione del codice. Può essere vista come un’attività complementare all’analisi dinamica. Il team utilizza due tecniche di analisi statica:
\begin{itemize}
  \item \textbf{Walkthrough};
  \item \textbf{Inspection}.
\end{itemize}

\subsubsubsection{Walkthrough}
\par Il walkthrough è una tecnica informale di analisi statica che prevede una lettura critica e approfondita del documento o del codice sorgente. Questo processo coinvolge il verificatore e l’autore (uno sviluppatore o un redattore). Il walkthrough è un'attività collaborativa, che può coinvolgere anche un team di tre o cinque persone. In caso di verifica del codice sorgente, i verificatori lo percorrono simulando possibili esecuzioni. Il walkthrough si articola nelle seguenti fasi:
\begin{itemize}
  \item \textbf{Pianificazione}: il verificatore e l'autore si accordano su come procedere con il walkthrough;
  \item \textbf{Lettura}: il codice o il documento viene letto dall'autore, mentre il verificatore annota i difetti riscontrati;
  \item \textbf{Discussione}: al termine della lettura, il verificatore comunica i problemi rilevati e propone eventuali suggerimenti, con l'obiettivo di correggere i difetti.
\end{itemize}

\subsubsubsection{Inspection}
\par L'inspection (o ispezione) è una tecnica formale di analisi statica che prevede una revisione sistematica e mirata del prodotto. A differenza del walkthrough, l’ispezione utilizza liste di controllo (checklist) per rilevare i difetti. In questo modo è possibile ricercare errori frequenti di programmazione o di altra natura, senza dover analizzare l’oggetto in esame nella sua interezza; pertanto, l’ispezione si concentra sulla verifica dei punti ritenuti critici. Le checklist possono derivare da conoscenze pregresse ottenute tramite walkthrough. L'ispezione si articola nelle seguenti fasi:
\begin{itemize}
  \item \textbf{Pianificazione}: il verificatore e l'autore si accordano su come procedere con l'ispezione;
  \item \textbf{Definizione delle checklist}: vengono definiti i punti critici del codice o della documentazione; le liste di controllo vengono aggiornate sulla base dell’esperienza acquisita e degli errori più ricorrenti;
  \item \textbf{Lettura}: il prodotto viene esaminato seguendo le liste di controllo;
  \item \textbf{Correzione dei difetti}: A seguito dell'ispezione, l'autore implementa le modifiche necessarie e intraprende le azioni correttive identificate;
  \item \textbf{Follow-up}: le modifiche apportate dall'autore vengono controllate per accertare la loro corretta implementazione.
\end{itemize}

\vspace{0.5\baselineskip}
\par Data l’inesperienza del team nell'attività di verifica, inizialmente è stata utilizzata la tecnica “walkthrough”. Ciò ha permesso al gruppo di rilevare gli errori più comuni e acquisire le conoscenze necessarie per definire le liste di controllo ed eseguire verifiche più mirate. Le checklist sono raccolte nel \PianoDiQualifica.

\subsubsection{Analisi dinamica}
\par L’analisi dinamica è un processo di verifica basato sull’osservazione del comportamento di un sistema software o di un suo componente in esecuzione. Spesso il termine "testing" viene utilizzato come sinonimo di analisi dinamica, poiché quest’ultima prevede la definizione di un insieme di prove (test), preferibilmente automatizzate e riproducibili. Le precondizioni necessarie per poter effettuare un test sono la configurazione dell'ambiente di esecuzione e la conoscenza del comportamento atteso (determinato dall'oracolo). Un oracolo è un metodo usato nel collaudo del software per determinare se un test ha avuto successo o è fallito. L’obiettivo dei test è produrre una misura quanto più oggettiva della qualità del prodotto e, di conseguenza, devono essere eseguiti in parallelo all'attività di codifica. Come parte del processo di analisi dinamica, il team ha individuato le seguenti tipologie di test da eseguire:
\begin{itemize}
  \item \textbf{Test di unità};
  \item \textbf{Test di integrazione};
  \item \textbf{Test di sistema}.
\end{itemize}

\subsubsection{Test di unità}
\par I test di unità sono una categoria di test del software che si focalizza sulla verifica del corretto funzionamento dei singoli moduli o componenti del codice. In genere, una “unità” è la più piccola porzione o segmento (una funzione, un metodo o una classe) testabile in modo autonomo e isolato all’interno del sistema. I test di unità vengono definiti durante la progettazione di dettaglio con l’obiettivo di individuare difetti o malfunzionamenti. La maggior parte dei difetti rilevati tramite analisi dinamica (circa 2/3 del totale) deriva dall’esecuzione dei test di unità. A ogni unità software può essere associata una suite o batteria di test. Nelle fasi iniziali dello sviluppo, il team potrebbe riscontrare delle difficoltà nel testare singole unità, poiché alcuni moduli o componenti potrebbero essere incompleti o non disponibili. Pertanto, sono stati introdotti degli strumenti a supporto dell'analisi dinamica:
\begin{itemize}
  \item \textbf{Stub} (o metodo stub): simula una funzionalità del sistema (non ancora codificata e non oggetto di test) come parte del processo di testing di un’unità software;
  \item \textbf{Driver}: componente di supporto che controlla l'esecuzione dei test e aiuta a configurare l'ambiente. Sostituisce il modulo chiamante di una funzionalità sotto test;
  \item \textbf{Mock object}: simula il comportamento di oggetti reali in condizioni controllate; può fornire una risposta preimpostata.
\end{itemize}

\vspace{0.5\baselineskip}
\par I test di unità si dividono in due categorie:
\begin{itemize}
  \item \textbf{Test funzionali} (black-box): utilizzano dati di ingresso capaci di provocare l’esito atteso. L'obiettivo è accertare che, fornito un determinato input e definita un'aspettativa di output, l'esecuzione di una funzionalità generi il comportamento previsto. I test black-box contribuiscono a misurare quante specifiche e requisiti funzionali sono soddisfatti dal prodotto software. Non possono valutare la correttezza e la completezza della logica interna dell’unità, pertanto devono essere integrati con test strutturali;
  \item \textbf{Test strutturali} (white-box): verificano la struttura interna dell’unità software, esaminando i cammini di esecuzione all’interno dell’unità stessa. L'obiettivo è valutare il funzionamento interno del software, analizzando la logica, i flussi di controllo e la copertura del codice.
\end{itemize}

\vspace{0.5\baselineskip}
\par Per l'esecuzione dei test funzionali e strutturali, il team utilizza strumenti di automazione appropriati e coerenti con le tecnologie e i linguaggi di programmazione selezionati. Ciascuna unità software deve rispettare le specifiche stabilite durante la progettazione di dettaglio.

\subsubsection{Test di integrazione}
\par I test di integrazione vengono definiti durante la progettazione architetturale e si basano sui componenti in essa specificati. L’integrazione può essere di tipo incrementale, aumentando il valore funzionale a ogni passo. Questo approccio prevede che i componenti vengano integrati in insiemi già verificati, agevolando la rimozione di eventuali difetti o malfunzionamenti in seguito a cambiamenti. Lo scopo dei test di integrazione è rilevare difetti di design o una scarsa qualità dei test di unità, garantendo che i dati scambiati attraverso ciascuna interfaccia siano conformi alle specifiche. Vi sono due modalità di integrazione incrementale:
\begin{itemize}
  \item \textbf{Bottom-up}: l’integrazione avviene partendo dai moduli più interni al sistema, che sono meno visibili a livello utente e possiedono un minor numero di dipendenze funzionali. Questa strategia richiede l’uso di pochi stub, ma può rallentare la fornitura di servizi di "alto livello". Nell’approccio bottom-up, i driver vengono utilizzati per testare i componenti nei layer inferiori, qualora i moduli nei layer superiori siano ancora incompleti;
  \item \textbf{Top-down}: l’integrazione avviene partendo dai moduli più esterni, che possiedono un maggior numero di dipendenze funzionali e sono quindi di maggior interesse per l’utente. Questa strategia richiede l'uso di molti stub per simulare i componenti mancanti, consentendo di integrare fin da subito le funzionalità di "alto livello".
\end{itemize}

\subsubsection{Test di sistema}
\par TODO

\subsubsection{Test: Notazione}
\par I test vengono identificati in modo univoco secondo questa notazione: 
\par \quad \textbf{T.[Tipo].[Codice]}
\par dove: 
\begin{itemize}
    \item \textbf{T}: indica la parola "test";
    \item \textbf{Tipo}: indica la tipologia di test: 
        \begin{itemize}
            \item \textbf{U} (Unità); 
            \item \textbf{I} (Integrazione);
            \item \textbf{S} (Sistema);
            \item \textbf{A} (Accettazione).
        \end{itemize}
    \item \textbf{Codice}: è un numero progressivo che identifica in modo univoco i test per ogni tipologia.
\end{itemize}

\subsubsection{Test: Stato}
\par Ogni test è corredato da un flag che segnala il suo stato, aggiornato in base alla versione corrente del prodotto software. Il flag può assumere i seguenti valori:
\begin{itemize}
    \item \textbf{N-D}: test non definito (o non disponibile);
    \item \textbf{S}: test eseguito con successo;
    \item \textbf{F}: test fallito.
\end{itemize}