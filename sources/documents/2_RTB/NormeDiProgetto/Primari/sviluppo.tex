\subsection{Sviluppo}\label{sviluppo}

\subsubsection{Descrizione}
Il \glossario{processo} di sviluppo contiene le attività e compiti dello \glossario{sviluppatore} sotto elencate:
\begin{itemize}
  \item Analisi dei requisiti;
  \item \glossario{Progettazione};
  \item \glossario{Codifica} e \glossario{testing}.
\end{itemize}


\subsubsection{Analisi dei Requisiti}\label{analisi}
\paragraph{Descrizione}
L'Analisi dei Requisiti è eseguita dall'Analista, che redige l'omonimo documento \AdR. Il documento considera i seguenti aspetti:
\begin{itemize}
  \item Descrizione del prodotto e caratteristiche ad alto livello;
  \item Elenco dei casi d'uso;
  \item Elenco dei requisiti.
\end{itemize}

\paragraph{Casi d'uso}
La struttura di un UC è divisa nella seguente struttura:
\begin{itemize}
  \item UCN - Nome UC;
  \item Descrizione;
  \item Attori principali;
  \item Precondizioni;
  \item Postcondizioni;
  \item Trigger;
  \item Scenario principale;
  \item Eventuale Scenario alternativo;
  \item Eventuale Inclusioni;
  \item Eventuali Estensioni;
  \item Eventuali sottocasi d'uso.
\end{itemize}
Nella scrittura e definizione di un UC va tenuto conto delle seguentio considerazioni:
\begin{itemize}
  \item Le precondizioni dello UC devono essere condizioni necessarie per arrivare alla situazione che si presenta nello UC.
  \item Le precondizioni vengono poste al passato per identificare la conclusione di un UC, possono includere altri UC;
  \item Le postcondizioni rappresentano cosa succede dopo lo sviluppo dello UC e sono pertanto descrittive e poste al presente;
  \item Lo scenario principale riprende i passaggi che sono stati necessari per il verificarsi dello UC. Pertanto si parte a descriverle dalla prima estensione che l'attore incontra dopo l'avvio dell'applicativo fino ad arrivare allo UC;
  \item Lo scenario alternativo riprende i passaggi dello scenario principale fino all'estensione che porta allo UC alternativo;
  \item Ogni riferimento ad un UC viene riportato in precondizioni, postcondizioni, scenario principale, scenario alternativo, inclusione ed estensione;
  \item I sottocasi d'uso di uno UC vengono inseriti sotto lo UC principale nello stesso file;
  \item I sottocasi sono sempre inclusioni del caso d'uso "padre";
  \item I sottocasi vengono riferiti con un punto dopo il padre. Ad esempio un caso d'uso potrebbe essere UC1 e il sottocaso UC1.1;
  \item Per gli errori si visualizza quasi sempre un messaggio. Quindi la postcondizione finale e la fine dello scenario principale sarà quasi sempre "Viene visualizzato un messaggio con i dettagli dell'errore";
  \item Il Trigger è l'azione che l'utente vuole svolgere e che viene soddisfatta dallo UC.
\end{itemize}

\paragraph{Requisiti}
I requisiti del prodotto, delineati durante il processo di analisi, si suddividono nelle seguenti categorie:
\begin{itemize}
  \item \textbf{Funzionali (F):} corrispondono alle funzionalità del sistema;
  \item \textbf{Qualitativi (Q):} garantiscono la qualità del prodotto;
  \item \textbf{Di vincolo (V):} indicano le restrizioni e i vincoli normativi del progetto;
\end{itemize}
Ciasun requisito ha anche un valore di importanza:
\begin{itemize}
  \item \textbf{Obbligatorio (O):} requisiti inderogabili;
  \item \textbf{Desiderabile (D):} requisiti non obbligatori, ma comunque di interesse per la \glossario{Proponente};
  \item \textbf{Opzionale (OP):} l'implementazione di questi requisiti è lasciata alla discrezione del \glossario{Fornitore}.
\end{itemize}
Data tale classificazione, i requisiti vengono identificati da un indice univoco con la seguente struttura:
\[R[Tipologia].[Importanza].[Codice]\]
Dove \emph{R} sta per Requisito, \emph{Tipologia} è la sigla associata alla categoria del requisito, \emph{Importanza} è la sigla per il valore di importanza e \emph{Codice} è un valore numerico univoco.\\
Descrivere le fonti è una pratica necessaria per orientare sia l'Analista che gli altri membri del gruppo verso una definizione più ampia e chiara del requisito, per cui ciascuna fonte di un requisito viene indicata assieme alla sua descrizione.

\subsubsection{Progettazione}\label{progettazione}
\subsubsubsection{Scopo}
\par L'attività di progettazione segue quella di analisi e ha lo scopo di definire un'architettura per il prodotto capace di soddisfare i requisiti specificati nell’\AnalisiDeiRequisiti. Questa attività viene svolta dai progettisti e prevede l'utilizzo di stili e pattern architetturali. La progettazione ha dunque il compito di assicurare il soddisfacimento delle caratteristiche individuate durante l'analisi. In genere, l'architettura è un sistema formato da componenti, che raggruppano delle unità software composte da uno o più moduli.

\par Una buona architettura dovrebbe possedere i seguenti attributi di qualità misurabili:
\begin{itemize}
  \item \textbf{Sufficienza}: adeguato livello di soddisfacimento dei requisiti;
  \item \textbf{Modularità}: scomposizione in elementi distinti tra loro e con compiti non sovrapposti;
  \item \textbf{Robustezza}: tolleranza a diverse classi di input;
  \item \textbf{Flessibilità}: capacità di adattarsi a cambiamenti sia adattivi che evolutivi;
  \item \textbf{Riusabilità}: agevola il riuso dei componenti in altri contesti;
  \item \textbf{Efficienza}: utilizzo ottimale delle risorse;
  \item \textbf{Affidabilità}: capacità di mantenere il livello di prestazioni in condizioni specifiche;
  \item \textbf{Semplicità}: minimizza i componenti ed evita l'introduzione di soluzioni o dettagli troppo complessi;
  \item \textbf{Incapsulamento}: nasconde i dettagli implementativi (black-box), con l'obiettivo di ridurre le dipendenze e aumentare la riusabilità e la manutenibilità;
  \item \textbf{Coesione}: gli elementi che concorrono agli stessi obiettivi devono essere raggruppati nello stesso componente;
  \item \textbf{Basso accoppiamento}: limita le dipendenze tra elementi distinti.
\end{itemize}

\subsubsubsection{Proof of Concept}\label{poc}
Oltre all’analisi dei requisiti, una precondizione necessaria per la revisione \glossario{RTB} è la dimostrazione della validità delle tecnologie scelte dal team. Sulla base delle richieste e delle necessità espresse dalla \glossario{Proponente}, il team valuta i pro e contro delle tecnologie disponibili, considerando fattori come la curva di apprendimento, le prestazioni e la modernità. Una volta ultimata la scelta tecnologica, i progettisti e i programmatori devono realizzare un \glossario{Proof of Concept}. Qualora il team ritenesse le tecnologie selezionate inadeguate, i progettisti e i programmatori saranno responsabili della realizzazione di un ulteriore Proof of Concept (PoC), avvalendosi, ove possibile, delle soluzioni già sviluppate. Lo scopo del \glossario{Poc} è:
\begin{itemize}
  \item Verificare la fattibilità del progetto;
  \item Dimostrare che il team è in grado di soddisfare i requisiti mediante l'uso delle tecnologie scelte;
  \item Acquisire un controllo quanto più completo delle tecnologie;
  \item Ricevere un feedback dalla \glossario{Proponente} in merito al grado di conformità delle soluzioni sviluppate rispetto al capitolato.
\end{itemize}

\subsubsubsection{Fasi di progettazione}\label{fasi-progettazione}
\par Seguendo il modello di sviluppo a V, l'attività di progettazione è suddivisa in due fasi: 
\begin{itemize}
  \item \textbf{Progettazione logica};
  \item \textbf{Progettazione di dettaglio}.
\end{itemize}

\subsubsubsection{Progettazione logica}\label{progettazione-logica}
\par La progettazione logica (o progettazione architetturale) è la prima fase di progettazione e ha lo scopo di delineare l'architettura software. I progettisti definiscono la struttura complessiva del sistema, identificando i componenti principali, le loro responsabilità e le relazioni tra di essi. Per assicurare la coerenza e la consistenza dell'architettura, il team prevede l'uso di stili architetturali, che forniscono una soluzione progettuale di "alto livello". Questa fase è essenziale per garantire che il sistema risponda ai requisiti funzionali e non funzionali. La progettazione logica include le seguenti attività:
\begin{itemize}
  \item Individuazione dei principali componenti del sistema;
  \item Definizione delle interfacce e delle modalità di comunicazione tra i componenti;
  \item Definizione delle strutture dati necessarie per soddisfare i requisiti;
  \item Stesura iniziale del manuale utente;
  \item Progettazione dei test di integrazione;
  \item Revisione delle soluzioni e degli stili architetturali.
\end{itemize}

\subsubsubsection{Progettazione di dettaglio}\label{progettazione-dettaglio}
\par La progettazione di dettaglio precede l’attività di codifica e la vincola in modo sostanziale. In questa fase vengono definiti gli attributi e i metodi delle classi, inclusi i relativi tipi di dato. Il team agisce sulle unità architetturali, che devono essere progettate con una complessità tale da consentire la codifica da parte di un singolo programmatore. Le unità dell’architettura vengono suddivise in moduli; più unità formano un componente (definito durante la progettazione logica). Lo scopo della progettazione di dettaglio è organizzare e disciplinare la fase di programmazione, documentando le scelte progettuali, assegnando i requisiti a ciascuna unità e definendo gli strumenti necessari per eseguire i test di unità. Il team deve trovare il giusto equilibrio tra scomposizione del sistema e complessità di coordinamento tra i moduli. La progettazione di dettaglio include le seguenti attività:
\begin{itemize}
  \item Descrizione dettagliata dei componenti, con enfasi sulla definizione specifica di ciascuna unità e modulo;
  \item Aggiornamento ed espansione del manuale utente;
  \item Definizione delle specifiche dei test di integrazione;
  \item Definizione delle specifiche dei test di unità.
\end{itemize}

\subsubsubsection{Specifica tecnica}\label{specifica-tecnica}
\par La fase di progettazione deve essere documentata in modo chiaro ed esaustivo, poiché costituisce la base fondamentale per le successive attività di codifica e testing del software. Le scelte progettuali sono dettagliate nel documento 'Specifica tecnica', la cui stesura inizia al termine della prima fase della revisione \glossario{RTB}.

\subsubsection{Codifica}\label{codifica}

\subsubsubsection{Scopo}
\par La codifica, effettuata dai programmatori, ha l'obiettivo di sviluppare il software in conformità con le specifiche architetturali definite dai progettisti. I programmatori traducono la struttura del sistema in codice sorgente utilizzando uno o più linguaggi di programmazione. Questa fase influisce sia sul testing che sulla manutenzione del software. Durante lo sviluppo, è essenziale che i programmatori aderiscano agli standard di programmazione stabiliti.

\subsubsubsection{Elementi comuni di stile}
\par Di seguito sono riportati gli elementi comuni di stile:
\begin{itemize}
  \item \textbf{Nomi autoesplicativi} (self-explanatory): i nomi di classi, metodi e variabili devono essere sufficientemente descrittivi da rendere chiaro il loro significato, scopo o contenuto senza necessità di ulteriori commenti esplicativi, salvo nei casi in cui la complessità del codice lo richieda. È fondamentale trovare un equilibrio tra lunghezza e chiarezza descrittiva;
  \item \textbf{Lingua}: utilizzare la lingua inglese per la nomenclatura all'interno del codice sorgente, inclusi i commenti;
  \item \textbf{Abbreviazioni}: utilizzare abbreviazioni e acronimi consolidati o riconosciuti dalla comunità informatica;
  \item \textbf{Sezioni incomplete}: vanno indicate con un commento preceduto dalla dicitura "TODO";
  \item \textbf{Sezioni in attesa di revisione o miglioramento}: vanno indicate con un commento preceduto dalla dicitura "FIXME";
  \item \textbf{Indentazione}: utilizzare quattro spazi o un carattere di tabulazione;
  \item \textbf{Spaziatura}: aggiungere uno spazio attorno agli operatori binari e ternari per migliorare la leggibilità del codice.
\end{itemize}

\subsubsubsection{Stile di codifica: Python}
\paragraph*{Struttura dei file}
\begin{itemize}
  \item \textbf{Import}: insieme di istruzioni per includere moduli, librerie o pacchetti nello script:
  \begin{itemize}
    \item Librerie interne o moduli personalizzati;
    \item Librerie standard o di terze parti.
  \end{itemize}
  \item \textbf{Variabili globali}: variabili accessibili in tutto il programma;
  \item \textbf{Classi}: definiscono un tipo di oggetto o raggruppano funzioni di utilità.
\end{itemize}

\paragraph*{Struttura delle classi}
\begin{itemize}
  \item \textbf{Riferimenti}: lista di classi base (ereditarietà) o interfaccia implementata;
  \item \textbf{Costruttore}: metodo speciale chiamato \verb|__init__| (inizializzatore);
  \item \textbf{Metodi}: funzioni definite all'interno di una classe;
  \item \textbf{Attributi}: variabili definite all'interno di una classe.
\end{itemize}

\vspace{0.5\baselineskip}
\par La documentazione del codice sorgente deve essere conforme alle linee guida di Google relative alla scrittura di \glossario{docstring} in Python. In particolare:
\begin{itemize}
  \item Ogni classe deve essere corredata da:
  \begin{itemize}
    \item Panoramica del ruolo o dello scopo della classe;
    \item Descrizione dettagliata (opzionale);
    \item Lista degli argomenti richiesti del costruttore;
    \item Lista degli attributi, accompagnati da una breve descrizione; 
    \item Lista dei metodi.
  \end{itemize}
  \item Ogni metodo deve essere corredato da:
  \begin{itemize}
    \item Panoramica del comportamento e della funzionalità del metodo;
    \item Descrizione dettagliata (opzionale);
    \item Lista degli argomenti, accompagnati da una breve descrizione; 
    \item Lista degli eventuali valori di ritorno, accompagnati da una breve descrizione;
    \item Lista delle eventuali eccezioni sollevate, accompagnate da una breve descrizione.
  \end{itemize}
\end{itemize}

\paragraph*{Best practices}
\begin{itemize}
  \item \textbf{Import}: importare moduli, librerie o pacchetti all'inizio del file, evitando l'uso dell'asterisco;
  \item \textbf{Self}: utilizzare la parola chiave "self" per riferirsi all'istanza dell'oggetto su cui viene chiamato un metodo;
  \item \textbf{Metodi setter e getter}: utilizzare metodi dedicati per interagire con gli attributi, evitando l'accesso diretto alle proprietà di una classe;
  \item \textbf{Concordanza nomi attributi-argomenti}: gli argomenti di un metodo devono avere lo stesso nome degli attributi corrispondenti nella classe;
  \item \textbf{Lunghezza massima riga (codice)}: 79 caratteri;
  \item \textbf{Lunghezza massima riga (commenti)}: 72 caratteri;
  \item \textbf{Lunghezza massima riga (docstring)}: 72 caratteri.
\end{itemize}

\paragraph*{Convenzioni sintattiche}
\begin{itemize}
  \item \textbf{Nomenclatura}: seguire le convenzioni stabilite da PEP 8;
  \item \textbf{Nomi della classi}: \glossario{PascalCase};
  \item \textbf{Nomi dei metodi}: \glossario{camelCase};
  \item \textbf{Nomi delle variabili}: \glossario{snake\_case};
  \item \textbf{Nomi delle costanti}: \glossario{UPPER\_SNAKE\_CASE};
  \item \textbf{Commenti}: utilizzare il simbolo \# per i commenti;
  \item \textbf{Docstring}: utilizzare il simbolo \verb|"""| per i commenti;
  \item \textbf{Stringhe}: utilizzare il simbolo \verb|'| oppure \verb|'''| per le stringhe.
\end{itemize}

\paragraph*{Formattazione del codice}
\par Il team aderisce alle convenzioni di formattazione stabilite da PEP 8 (Python Enhancement Proposal 8), la guida ufficiale per lo stile di codifica Python pubblicata dalla Python Software Foundation (PSF). Il rispetto delle linee guida è assicurato e automatizzato tramite uno strumento integrato nell'estensione Python di Visual Studio Code.

\paragraph{Componenti e viste Vue}
\begin{itemize}
  \item \textbf{Nome dei file:} PascalCase;
\end{itemize}
Un componente/vista contiene 3 sezioni:
\begin{itemize}
  \item \textbf{Script}: codice JavaScript/TypeScript che gestisce la logica del componente;
  \item \textbf{Template}: HTML della struttura del componente;
  \item \textbf{Style}: CSS dell'aspetto del componente.
\end{itemize}
Queste sezioni appaiono nel file del componente, nell'ordine: \textbf{script}, \textbf{template}, \textbf{style}.

\paragraph{JavaScript/TypeScript}
\begin{itemize}
  \item \textbf{Nome delle variabili:} camelCase;
  \item \textbf{Nome dei metodi:} camelCase;
\end{itemize}

\paragraph{CSS}

\begin{itemize}
  \item \textbf{Organizzazione}: Il CSS è organizzato in tre sezioni:
  \begin{itemize}
    \item \textbf{Layout}: nella cartella \texttt{frontend/src/assets/layout}, dove sono presenti i file CSS che definiscono la struttura generale del layout dell'applicazioni, comprendendo classi comuni per la gestione di griglie, allineamenti e margini;
    \item \textbf{Componente}: CSS del singolo componente, utile a definire la sua caratteristica disposizione, è descritto nel file stesso del componente, in modo da mantenere la modularità;
    \item \textbf{Temi}: nella cartella \texttt{frontend/public/themes}, che contiene cartelle di temi CSS che definiscono l'aspetto estetico, applicabile all'applicazione, ad esempio tema scuro e chiaro sono definiti in questa cartella.
  \end{itemize}
  \item \textbf{Nome delle classi}: kebab-case;
  \item \textbf{Nome degli id}: kebab-case;
\end{itemize}

\subsubsection{Testing}\label{testing}
\par Il testing è un'attività necessaria ad assicurare la correttezza di ciascuna unità software.

\par TODO (da mettere i punti già definiti in Verifica)